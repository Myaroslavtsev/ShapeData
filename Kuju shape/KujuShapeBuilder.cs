/// Transforms EditorShape into large strings to be further saved in .s, .sd, .ref and .bat files.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ShapeData.Editor_shapes;
using System.Numerics;
using System.Globalization;

namespace ShapeData.Kuju_shape
{
    class KujuShapeBuilder
    {
        private const string newLine = "\r\n";

        public static (string s, string sd) BuildShapeFile(EditorShape shape,
            bool prohibitVisualObstruction = false,
            bool hasWinterTextures = false)
        {
            System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");

            var prepared = new ShapePreparator(shape);

            return (
                AssembleShapeFileParts(shape, prepared),
                AssembleShapeDefinitionParts(shape.ShapeName, prepared.BoundingBox, 
                prohibitVisualObstruction, hasWinterTextures)
            );
        }

        private static string AssembleShapeFileParts(EditorShape shape, ShapePreparator preparedShape)
        {
            var sb = new StringBuilder();

            var kujuShape = new DataBlock("shape", null);

            sb.Append("SIMISA@@@@@@@@@@JINX0s1t______" + newLine + newLine);

            kujuShape.AddBlock(ShapeHeader());
            kujuShape.AddBlock(ShapeVolumes(preparedShape.BoundingBox));
            kujuShape.AddBlock(ShapeShaderNames(preparedShape.Shaders));
            kujuShape.AddBlock(ShapeTextureFilterNames());
            kujuShape.AddBlock(ShapePoints(preparedShape.Points));
            kujuShape.AddBlock(ShapeUvPoints(preparedShape.UvPoints));
            kujuShape.AddBlock(ShapeNormals(preparedShape.Normals));
            kujuShape.AddBlock(ShapeSortVectors());
            kujuShape.AddBlock(ShapeColours());
            kujuShape.AddBlock(ShapeMatrices());
            kujuShape.AddBlock(ShapeImages(preparedShape.Images));
            kujuShape.AddBlock(ShapeTextures(preparedShape.Images));
            kujuShape.AddBlock(ShapeLightMaterials());
            kujuShape.AddBlock(ShapeLightModelConfigs());
            kujuShape.AddBlock(ShapeVertexStates(preparedShape.LightMatIds));
            kujuShape.AddBlock(ShapePrimStates(preparedShape.PrimStates));
            kujuShape.AddBlock(ShapeLodControls(shape, preparedShape));

            kujuShape.PrintBlock(sb);

            return sb.ToString();
        }      

        private static string AssembleShapeDefinitionParts(
            string shapeName,
            (Vector3, Vector3) boundingBox,
            bool prohibitVisualObstruction = false,
            bool hasWinterTextures = false)
        {
            var sb = new StringBuilder();

            sb.Append("SIMISA@@@@@@@@@@JINX0t1t______" + newLine + newLine);

            var kujuShape = new DataBlock("shape", new List<string> { shapeName });
            kujuShape.AddBlock(EsdDetailLevel());
            kujuShape.AddBlock(AlternativeTextures(hasWinterTextures));
            kujuShape.AddBlock(BoundingBox(boundingBox, prohibitVisualObstruction));

            kujuShape.PrintBlock(sb);

            return sb.ToString();
        }

        public static DataBlock GetRefFileEntry(string shapeName, string categoryName = "Autogenerated models") =>
            new("Static", null, new List<DataBlock> {
                new DataBlock("Shadow", new List<string> { "None" }),
                new DataBlock("Class", new List<string> { categoryName }),
                new DataBlock("Filename", new List<string> { shapeName }),
                new DataBlock("Align", new List<string> { "None" }),
                new DataBlock("Description", new List<string> { shapeName }) });

        public static string GetFfeditCommandLine(string directory, string shapeName)
        {
            var shapePathAndName = '"' + directory + shapeName + '"';
            return "ffeditc_unicode.exe " + shapePathAndName + " /o:" + shapeName + "\r\n";
        }
                    
        private static DataBlock ShapeLodControls(EditorShape shape, ShapePreparator preparedShape)
        {
            var lodsBlock = new DataBlock("distance_levels", new List<string> { shape.Lods.Count.ToString() });

            foreach (var lod in shape.Lods)
                lodsBlock.AddBlock(DistanceLevelBlock(lod, preparedShape));

            return new DataBlock("lod_controls", new List<string> { shape.Lods.Count.ToString() },
                new List<DataBlock> {
                    new DataBlock("lod_control", new List<string> (), 
                    new List<DataBlock> {
                        new DataBlock("distance_levels_header", new List<string> { "0" }),
                        lodsBlock}) });
        }

        private static DataBlock DistanceLevelBlock(EditorLod lod, ShapePreparator preparedShape)
        {
            var dlBlock = new DataBlock("distance_level", null);

            dlBlock.AddBlock(new DataBlock("distance_level_header", null, new List<DataBlock> { 
                new DataBlock("dlevel_selection", new List<string> { lod.Distance.ToString() }),
                new DataBlock("hierarchy", new List<string> { "1", "-1" }) // differs for animated shapes
            }));

            dlBlock.AddBlock(new DataBlock("sub_objects", new List<string> { "1" }, new List<DataBlock> { SubObjectBlock(lod, preparedShape) }));

            return dlBlock;
        }

        private static DataBlock SubObjectBlock(EditorLod lod, ShapePreparator preparedShape) =>        
            new ("sub_object", null, new List<DataBlock> {
                SubObjectHeaderBlock(lod, preparedShape),
                VerticesBlock(lod),
                VertexSetsBlock(lod), // only in lod should be given
                PrimitivesBlock(lod)
            });

        private static DataBlock SubObjectHeaderBlock(EditorLod lod, ShapePreparator preparedShape)
        // no sort vectors, use general vector; no volumes, use bounding box
        {
            var triangles = lod.TriangleCount();

            var normalsCount = triangles.ToString();
            var vertexStateCount = preparedShape.LightMatIds.Count.ToString();
            var angleCount = (triangles * 3).ToString(); // doesn't count vertices used by several polys twice
            var trilistCount = lod.GetPrimStateIdSet().Count.ToString();

            return new ("sub_object_header", new List<string> { 
                "00000400", "-1", "-1",  "000001d2", "000001c4"},
                new List<DataBlock> { 
                    new DataBlock("geometry_info", new List<string> {
                        normalsCount,
                        vertexStateCount,
                        "0",
                        angleCount, // or triangles.Count * 3
                        "0", "0",
                        trilistCount,
                        "0", "0", "0"
                    }, new List<DataBlock> { 
                        new DataBlock("geometry_nodes", new List<string> { "1" }, new List<DataBlock> { 
                            new DataBlock("geometry_node", new List<string> {
                                preparedShape.LightMatIds.Count.ToString(),
                                "0", "0", "0", "0"
                            }, new List<DataBlock>{ 
                                new DataBlock("cullable_prims", new List<string>{ 
                                    trilistCount, // here for one matrix only
                                    normalsCount,
                                    angleCount
                                })
                            })                        
                        }),
                        new DataBlock("geometry_node_map", new List<string> { 
                            "1", "0" // or may be "2", "0", "-1" that means the same (that second matrix is excluded)
                        })
                    }),
                    new DataBlock("subobject_shaders", new List<string> { MakeCountString(preparedShape.Shaders.Count) }),
                    new DataBlock("subobject_light_cfgs", new List<string>{ "1", "0" }, null, new List<string>{ "0" })
                });
        }

        private static string MakeCountString(int Count)
        {
            string s = Count.ToString();

            for (int i = 0; i < Count; i++)
                s += ' ' + i.ToString();

            return s;
        }

        private static DataBlock VerticesBlock(EditorLod lod)
        {
            var vBlock = new DataBlock("vertices", new List<string> { lod.KujuVerticeList.Count.ToString() });

            foreach(var (pointId, normalId, uvPointId) in lod.KujuVerticeList)
            {
                vBlock.AddBlock(new DataBlock("vertex", new List<string> {
                    "00000000",
                    pointId.ToString(),
                    normalId.ToString(),
                    "ffffffff",
                    "ff000000"
                }, new List<DataBlock> {
                    new DataBlock("vertex_uvs", new List<string>{ "1", uvPointId.ToString() })
                }));
            }
            
            return vBlock;
        }
        
        private static DataBlock VertexSetsBlock(EditorLod lod) =>       
            new ("vertex_sets", new List<string> { "1" }, new List<DataBlock> {
                new DataBlock("vertex_set", new List<string> { "0", "0", lod.KujuVerticeList.Count.ToString()}) }) ;       

        private static DataBlock PrimitivesBlock(EditorLod lod)
        {
            var primStateIds = lod.GetPrimStateIdSet();

            var pBlock = new DataBlock("primitives", new List<string>{ (primStateIds.Count * 2).ToString() } );

            foreach(var primStateId in primStateIds)
            {
                pBlock.AddBlock(new DataBlock("prim_state_idx", new List<string> { primStateId.ToString() }));

                pBlock.AddBlock(TrilistBlock(lod, primStateId));
            }

            return pBlock;
        }

        private static DataBlock TrilistBlock(EditorLod lod, int primStateId)
        {
            var vertexIds = new List<int>();
            var normalIds = new List<int>();

            foreach(var poly in lod.Polygons())
                if (poly.KujuPrimStateId == primStateId)
                {
                    for(int corner = 2; corner < poly.Vertices.Count; corner++)
                    {
                        vertexIds.Add(poly.Vertices[0].KujuVertexId);
                        vertexIds.Add(poly.Vertices[corner - 1].KujuVertexId);
                        vertexIds.Add(poly.Vertices[corner].KujuVertexId);

                        normalIds.Add(poly.KujuNormalId);
                        normalIds.Add(3);
                    }
                }

            var vertexIdList = new List<string> { vertexIds.Count.ToString() };
            vertexIdList.AddRange(vertexIds.Select(id => id.ToString()));

            var normalIdList = new List<string> { (0.5 * normalIds.Count).ToString() };
            normalIdList.AddRange(normalIds.Select(id => id.ToString()));

            var flagList = new List<string> { (0.5 * normalIds.Count).ToString() };
            for (int i = 0; i < 0.5 * normalIds.Count; i++)
                flagList.Add("00000000");

            var trilistBlock = new DataBlock("indexed_trilist", null, new List<DataBlock>());
            trilistBlock.AddBlock(new DataBlock("vertex_idxs", vertexIdList ));
            trilistBlock.AddBlock(new DataBlock("normal_idxs", normalIdList));
            trilistBlock.AddBlock(new DataBlock("flags", flagList));

            return trilistBlock;
        }

        private static DataBlock ShapePrimStates(List<PrimState> primStates)
        {
            var dataBlock = new DataBlock("prim_states", new List<string> { primStates.Count.ToString() });

            foreach(var ps in primStates)
            {
                dataBlock.AddBlock(new DataBlock(
                    "prim_state " + ps.Name, new List<string> { "00000000", ps.ShaderId.ToString() },
                    new List<DataBlock> { new DataBlock("tex_idxs", 
                        new List<string> { "1", ps.TextureId.ToString() }, null,
                        new List<string> { 
                            "0", 
                            ps.IsBright.ToString(), 
                            ps.IsTransparent.ToString(), 
                            "0", 
                            ps.DrawOrder.ToString() }) }));
            }

            return dataBlock;
        }

        private static DataBlock ShapeVertexStates(List<int> lightMatIds) =>
            MakeShapeItemList(lightMatIds, // second parameter is matrix id (when more than one present) // last digit may be 0
                id => new List<string> { "00000000", "0", id.ToString(), "0", "00000000" }, "vtx_states", "vtx_state");

        private static DataBlock ShapeLightMaterials() =>
            new ("light_materials", new List<string> { "0" });

        private static DataBlock ShapeLightModelConfigs() =>
                new ("light_model_cfgs", new List<string> { "1" }, new List<DataBlock> {
                    new DataBlock("light_model_cfg", new List<string> { "00000000" }, new List<DataBlock> {
                        new DataBlock("uv_ops", new List<string> { "1" }, new List<DataBlock> {
                            new DataBlock("uv_op_copy", new List<string> { "1", "0" })
                        }) }) });

        private static DataBlock ShapeTextures(List<string> images) =>
            MakeShapeItemList(images, s => new List<string> { 
                images.IndexOf(s).ToString(), "0", "-3", "ff000000" }, "textures", "texture");

        private static DataBlock ShapeImages(List<string> images) =>
            MakeShapeItemList(images, s => new List<string> { s + ".ace" }, "images", "image");

        private static DataBlock ShapeShaderNames(List<string> shaders) =>
            MakeShapeItemList(shaders, s => new List<string> { s }, "shader_names", "named_shader");

        private static DataBlock ShapeNormals(List<Vector3> normals) =>
            MakeShapeItemList(normals, n => new List<string> { 
                n.X.ToString(), n.Y.ToString(), n.Z.ToString() }, "normals", "vector");

        private static DataBlock ShapeUvPoints(List<Vector2> uvPoints) =>
            MakeShapeItemList(uvPoints, p => new List<string> {
                p.X.ToString(), p.Y.ToString() }, "uv_points", "uv_point");

        private static DataBlock ShapePoints(List<Vector3> points) =>
            MakeShapeItemList(points, p => new List<string> {
                p.X.ToString(), p.Y.ToString(), p.Z.ToString() }, "points", "point");

        private static DataBlock ShapeMatrices()
        {
            // implemented correctly for non-animated objects only
            // difference between Square, Box, Polygon matrices unknown but may be crucial
            var matrix = new DataBlock("matrix Box", new List<string> { "1 0 0 0 1 0 0 0 1 0 0 0" });

            return new DataBlock("matrices", new List<string> { "1" }, new List<DataBlock> { matrix });
        }

        private static DataBlock ShapeSortVectors() =>
            new ("sort_vectors", new List<string> { "0" });
        
        private static DataBlock ShapeColours() =>
            new ("colours", new List<string> { "0" });        

        private static DataBlock ShapeTextureFilterNames()
        {
            var filterMode = new DataBlock("named_filter_mode", new List<string> { "MipLinear" });

            return new DataBlock("texture_filter_names", new List<string> { "1" }, 
                new List<DataBlock> { filterMode });
        }

        private static DataBlock ShapeVolumes((Vector3 minPoint, Vector3 maxPoint) bb)
        {
            var sum = bb.minPoint + bb.maxPoint;
            var delta = bb.maxPoint - bb.minPoint;

            var vector = new DataBlock("vector", new List<string> {
                            (0.5f * sum.X).ToString(), (0.5f * sum.Y).ToString(), (0.5f * sum.Z).ToString()
                        }, null, new List<string> {
                            ((float)(0.5f * delta.Length())).ToString()
                        });

            var vol_sphere = new DataBlock("vol_sphere", null, new List<DataBlock> { vector });

            return new DataBlock("volumes", new List<string> { "1" }, new List<DataBlock> {  vol_sphere } );            
        }

        private static DataBlock BoundingBox((Vector3 minPoint, Vector3 maxPoint) bb, bool prohibitVisualObstruction)
        {
            if (prohibitVisualObstruction)
                return new DataBlock("ESD_No_Visual_Obstruction", null);
            else
                return new DataBlock("ESD_Bounding_Box", new List<string> {
                    bb.minPoint.X.ToString(), bb.minPoint.Y.ToString(), bb.minPoint.Z.ToString(),
                    bb.maxPoint.X.ToString(), bb.maxPoint.Y.ToString(), bb.maxPoint.Z.ToString() });
        }

        private static DataBlock AlternativeTextures(bool hasWinterTextures)
        {
            if (hasWinterTextures)
                return new DataBlock("ESD_Alternative_Texture", new List<string> { "1" });
            else
                return new DataBlock("ESD_Alternative_Texture", new List<string> { "0" });
        }

        private static DataBlock EsdDetailLevel() =>
            new ("ESD_Detail_Level", new List<string> { "0" });

        private static DataBlock ShapeHeader() =>
            new ("shape_header", new List<string> { "00000000", "00000000" });

        private static DataBlock MakeShapeItemList<T>(
            List<T> items,
            Func<T, List<string>> getItemValues,
            string blockName,
            string itemName)
        {
            var dataBlock = new DataBlock(blockName, new List<string> { items.Count.ToString() });

            foreach (var i in items)
                dataBlock.AddBlock(new DataBlock(itemName, getItemValues(i)));

            return dataBlock;
        }
    }
}
